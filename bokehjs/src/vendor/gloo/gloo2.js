/* Do not edit, autogenerated by flexx.pyscript */

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
    } else if (typeof exports !== 'undefined') {
        // Node or CommonJS
        module.exports = factory();
        if (typeof window === 'undefined') {
            root.gloo2 = module.exports;  // also create global module in Node
        }
    } else {
        // Browser globals (root is window)
        root.gloo2 = factory();
    }
}(this, function () {

    var Buffer, GlooObject, IndexBuffer, Program, Texture2D, VertexBuffer, check_error;
    // PyScript module for gloo.js
    // Lightweight gloo

    check_error = function (gl, when) {
        var dummy1_sequence, dummy2_iter, dummy3_length, e, err, err_3, errors, msg;
        when = (when === undefined) ? 'periodic check': when;
        // Check this from time to time to detect GL errors.
        // 
        //     Parameters
        //     ----------
        //     when : str
        //         Shown in the exception to help the developer determine when
        //         this check was done.
        errors = [];
        while (true) {
            err = gl.getError();
            if ((err == gl.NO_ERROR) || (errors && (err == (errors[errors.length -1])))) {
                break;
            }
            (errors.append || errors.push).apply(errors, [err]);
        }
        if (errors.length) {
            msg = '';
            dummy1_sequence = errors;
            if ((typeof dummy1_sequence === "object") && (!Array.isArray(dummy1_sequence))) {
                dummy1_sequence = Object.keys(dummy1_sequence);
            }
            dummy3_length = dummy1_sequence.length;
            for (dummy2_iter = 0; dummy2_iter < dummy3_length; dummy2_iter += 1) {
                e = dummy1_sequence[dummy2_iter];
                msg += e
            }
            err_3 = new Error('RuntimeError:' + ('OpenGL got errors (' + when + '): ' + msg + '')); err_3.name = "RuntimeError"; throw err_3;
        }
    };

    GlooObject = function () {
        // Abstract base class for all Gloo classes.
        if (this.__init__) {
           this.__init__.apply(this, arguments);
        }
    };
    GlooObject.prototype._base_class = Object;
    

    GlooObject.prototype.__init__ = function (gl) {
        this._gl = gl;
        this._handle = null;
        this._create();
        if (!(this._handle !== null)) {throw "AssertionError: this._handle !== null";}
    };

    GlooObject.prototype._create = function () {
        var err_2;
        err_2 = new Error('NotImplementedError:' + ""); err_2.name = "NotImplementedError"; throw err_2;
    };


    Program = function () {
        // The program.
        // combines vertex and fragment shader
        if (this.__init__) {
           this.__init__.apply(this, arguments);
        }
    };
    Program.prototype = Object.create(GlooObject.prototype);
    Program.prototype._base_class = GlooObject.prototype;
    

    Program.prototype.UTYPEMAP = {'float': 'uniform1fv', 'vec2': 'uniform2fv', 'vec3': 'uniform3fv', 'vec4': 'uniform4fv', 'int': 'uniform1iv', 'ivec2': 'uniform2iv', 'ivec3': 'uniform3iv', 'ivec4': 'uniform4iv', 'bool': 'uniform1iv', 'bvec2': 'uniform2iv', 'bvec3': 'uniform3iv', 'bvec4': 'uniform4iv', 'mat2': 'uniformMatrix2fv', 'mat3': 'uniformMatrix3fv', 'mat4': 'uniformMatrix4fv', 'sampler1D': 'uniform1i', 'sampler2D': 'uniform1i', 'sampler3D': 'uniform1i'};
    Program.prototype.ATYPEMAP = {'float': 'vertexAttrib1f', 'vec2': 'vertexAttrib2f', 'vec3': 'vertexAttrib3f', 'vec4': 'vertexAttrib4f'};
    Program.prototype.ATYPEINFO = {'float': [1, 5126], 'vec2': [2, 5126], 'vec3': [3, 5126], 'vec4': [4, 5126]};
    Program.prototype._create = function () {
        this._handle = this._gl.createProgram();
        this._handles = [];
        this._unset_variables = [];
        this._validated = false;
        this._samplers = {};
        this._attributes = {};
        this._known_invalid = [];
    };

    Program.prototype.delete = function () {
        this._gl.deleteProgram(this._handle);
    };

    Program.prototype.activate = function () {
        this._gl.useProgram(this._handle);
    };

    Program.prototype.deactivate = function () {
        this._gl.useProgram(0);
    };

    Program.prototype.set_shaders = function (vert, frag) {
        var code, dummy4_, err_3, err_4, errors, frag_handle, gl, handle, i, status, tmp, type_, vert_handle;
        // This function takes care of setting the shading code and
        // compiling+linking it into a working program object that is ready
        // to use.
        gl = this._gl;
        this._linked = false;
        vert_handle = gl.createShader(gl.VERTEX_SHADER);
        frag_handle = gl.createShader(gl.FRAGMENT_SHADER);
        tmp = [[vert, vert_handle, 'vertex'], [frag, frag_handle, 'fragment']];
        for (i = 0; i < 2; i += 1) {
            dummy4_ = tmp[i];
            code = dummy4_[0];handle = dummy4_[1];type_ = dummy4_[2];
            gl.shaderSource(handle, code);
            gl.compileShader(handle);
            status = gl.getShaderParameter(handle, gl.COMPILE_STATUS);
            if (!status) {
                errors = gl.getShaderInfoLog(handle);
                err_4 = new Error('RuntimeError:' + ((('errors in ' + type_) + ' shader:\n') + errors)); err_4.name = "RuntimeError"; throw err_4;
            }
        }
        gl.attachShader(this._handle, vert_handle);
        gl.attachShader(this._handle, frag_handle);
        gl.linkProgram(this._handle);
        if (!(gl.getProgramParameter(this._handle, gl.LINK_STATUS))) {
            err_3 = new Error('RuntimeError:' + ('Program link error:\n' + (gl.getProgramInfoLog(this._handle)))); err_3.name = "RuntimeError"; throw err_3;
        }
        gl.detachShader(this._handle, vert_handle);
        gl.detachShader(this._handle, frag_handle);
        gl.deleteShader(vert_handle);
        gl.deleteShader(frag_handle);
        this._unset_variables = this._get_active_attributes_and_uniforms();
        this._handles = {};
        this._known_invalid = [];
        this._linked = true;
    };

    Program.prototype._get_active_attributes_and_uniforms = function () {
        var attributes, ca, container, count, cu, dummy10_iter, dummy11_length, dummy12_sequence, dummy13_iter, dummy14_length, dummy5_, dummy6_sequence, dummy7_iter, dummy8_length, dummy9_sequence, func, gl, i, info, m, name, regex, uniforms, v, x;
        // Retrieve active attributes and uniforms to be able to check that
        // all uniforms/attributes are set by the user.
        gl = this._gl;
        regex = new RegExp('(\\w+)\\s*(\\[(\\d+)\\])\\s*');
        cu = gl.getProgramParameter(this._handle, gl.ACTIVE_UNIFORMS);
        ca = gl.getProgramParameter(this._handle, gl.ACTIVE_ATTRIBUTES);
        attributes = [];
        uniforms = [];
        dummy6_sequence = [[attributes, ca, gl.getActiveAttrib], [uniforms, cu, gl.getActiveUniform]];
        if ((typeof dummy6_sequence === "object") && (!Array.isArray(dummy6_sequence))) {
            dummy6_sequence = Object.keys(dummy6_sequence);
        }
        dummy8_length = dummy6_sequence.length;
        for (dummy7_iter = 0; dummy7_iter < dummy8_length; dummy7_iter += 1) {
            x = dummy6_sequence[dummy7_iter];
            dummy5_ = x;
            container = dummy5_[0];count = dummy5_[1];func = dummy5_[2];
            for (i = 0; i < count; i += 1) {
                info = func.call(gl, this._handle, i);
                name = info.name;
                m = name.match(regex);
                if (m) {
                    name = m.group(0);
                    for (i = 0; i < info.size; i += 1) {
                        (container.append || container.push).apply(container, [['' + name + '[' + i + ']', info.type]]);
                    }
                } else {
                    (container.append || container.push).apply(container, [[name, info.type]]);
                }
            }
        }
        x = [];
        dummy9_sequence = attributes;
        if ((typeof dummy9_sequence === "object") && (!Array.isArray(dummy9_sequence))) {
            dummy9_sequence = Object.keys(dummy9_sequence);
        }
        dummy11_length = dummy9_sequence.length;
        for (dummy10_iter = 0; dummy10_iter < dummy11_length; dummy10_iter += 1) {
            v = dummy9_sequence[dummy10_iter];
            (x.append || x.push).apply(x, [v[0]]);
        }
        dummy12_sequence = uniforms;
        if ((typeof dummy12_sequence === "object") && (!Array.isArray(dummy12_sequence))) {
            dummy12_sequence = Object.keys(dummy12_sequence);
        }
        dummy14_length = dummy12_sequence.length;
        for (dummy13_iter = 0; dummy13_iter < dummy14_length; dummy13_iter += 1) {
            v = dummy12_sequence[dummy13_iter];
            (x.append || x.push).apply(x, [v[0]]);
        }
        return x;
    };

    Program.prototype.set_texture = function (name, value) {
        var dummy15_, dummy16_, dummy17_, dummy18_, err_3, handle, unit;
        // Set a texture sampler. Value is the id of the texture to link.
        if (!this._linked) {
            err_3 = new Error('RuntimeError:' + 'Cannot set uniform when program has no code'); err_3.name = "RuntimeError"; throw err_3;
        }
        handle = (/*py-dict.get*/typeof (dummy15_=this._handles).get==="function" ? dummy15_.get(name, -1) : (dummy15_[name] || (-1)));
        if (handle < 0) {
            if (((dummy16_ = this._known_invalid).indexOf ? dummy16_ : Object.keys(dummy16_)).indexOf(name) >= 0) {
                return;
            }
            handle = this._gl.getUniformLocation(this._handle, name);
            if (((dummy17_ = this._unset_variables).indexOf ? dummy17_ : Object.keys(dummy17_)).indexOf(name) >= 0) {
                (this._unset_variables.remove || function (x) {this.splice(this.indexOf(x), 1);}).apply(this._unset_variables, [name]);
            }
            this._handles[name] = handle;
            if (handle < 0) {
                (this._known_invalid.append || this._known_invalid.push).apply(this._known_invalid, [name]);
                console.log(('Variable ' + name + ' is not an active uniform'));
                return;
            }
        }
        this.activate();
        if (true) {
            unit = (Object.keys(this._samplers)).length;
            if (((dummy18_ = this._samplers).indexOf ? dummy18_ : Object.keys(dummy18_)).indexOf(name) >= 0) {
                unit = this._samplers[name][(this._samplers[name]).length -1];
            }
            this._samplers[name] = [value._target, value._handle, unit];
            this._gl.uniform1i(handle, unit);
        }
    };

    Program.prototype.set_uniform = function (name, type_, value) {
        var count, dummy19_, dummy20_, dummy21_, dummy22_, dummy23_, err_3, funcname, handle, ii, name_;
        // Set a uniform value. Value is assumed to have been checked.
        if (!this._linked) {
            err_3 = new Error('RuntimeError:' + 'Cannot set uniform when program has no code'); err_3.name = "RuntimeError"; throw err_3;
        }
        handle = (/*py-dict.get*/typeof (dummy19_=this._handles).get==="function" ? dummy19_.get(name, -1) : (dummy19_[name] || (-1)));
        count = 1;
        if (handle < 0) {
            if (((dummy20_ = this._known_invalid).indexOf ? dummy20_ : Object.keys(dummy20_)).indexOf(name) >= 0) {
                return;
            }
            handle = this._gl.getUniformLocation(this._handle, name);
            if (((dummy21_ = this._unset_variables).indexOf ? dummy21_ : Object.keys(dummy21_)).indexOf(name) >= 0) {
                (this._unset_variables.remove || function (x) {this.splice(this.indexOf(x), 1);}).apply(this._unset_variables, [name]);
            }
            if (!(type_.indexOf('mat') == 0)) {
                count = Math.floor(value.length/(this.ATYPEINFO[type_][0]));
            }
            if (count > 1) {
                for (ii = 0; ii < count; ii += 1) {
                    if (((dummy22_ = this._unset_variables).indexOf ? dummy22_ : Object.keys(dummy22_)).indexOf(('' + name + '[' + ii + ']')) >= 0) {
                        name_ = '' + name + '[' + ii + ']';
                        if (((dummy23_ = this._unset_variables).indexOf ? dummy23_ : Object.keys(dummy23_)).indexOf(name_) >= 0) {
                            (this._unset_variables.remove || function (x) {this.splice(this.indexOf(x), 1);}).apply(this._unset_variables, [name_]);
                        }
                    }
                }
            }
            this._handles[name] = handle;
            if (handle < 0) {
                this._known_invalid.add(name);
                logger.info('Variable ' + name + ' is not an active uniform');
                return;
            }
        }
        funcname = this.UTYPEMAP[type_];
        this.activate();
        (this._gl[funcname])(handle, value);
    };

    Program.prototype.set_attribute = function (name, type_, vbo_info, value) {
        var args, dummy24_, dummy25_, dummy26_, dummy27_, dummy28_, err_3, funcname, gtype, handle, offset, size, stride, vbo;
        value = (value === undefined) ? null: value;
        // Set an attribute value. vbo_info is (vbo, stride, offset).
        // It can also be null, in which case value must be an array with
        // the actual values to apply to all vertices (as in a uniform).
        if (!this._linked) {
            err_3 = new Error('RuntimeError:' + 'Cannot set attribute when program has no code'); err_3.name = "RuntimeError"; throw err_3;
        }
        handle = (/*py-dict.get*/typeof (dummy24_=this._handles).get==="function" ? dummy24_.get(name, -1) : (dummy24_[name] || (-1)));
        if (handle < 0) {
            if (((dummy25_ = this._known_invalid).indexOf ? dummy25_ : Object.keys(dummy25_)).indexOf(name) >= 0) {
                return;
            }
            handle = this._gl.getAttribLocation(this._handle, name);
            if (((dummy26_ = this._unset_variables).indexOf ? dummy26_ : Object.keys(dummy26_)).indexOf(name) >= 0) {
                (this._unset_variables.remove || function (x) {this.splice(this.indexOf(x), 1);}).apply(this._unset_variables, [name]);
            }
            this._handles[name] = handle;
            if (handle < 0) {
                (this._known_invalid.append || this._known_invalid.push).apply(this._known_invalid, [name]);
                if (vbo_info && ((vbo_info[0]) != 0) && ((vbo_info[2]) > 0)) {
                    return;
                }
                console.log(('Variable ' + name + ' is not an active attribute'));
                return;
            }
        }
        this.activate();
        if (vbo_info === null) {
            funcname = this.ATYPEMAP[type_];
            this._attributes[name] = [0, handle, funcname, value];
        } else {
            dummy27_ = vbo_info;
            vbo = dummy27_[0];stride = dummy27_[1];offset = dummy27_[2];
            dummy28_ = this.ATYPEINFO[type_];
            size = dummy28_[0];gtype = dummy28_[1];
            funcname = 'vertexAttribPointer';
            args = [size, gtype, this._gl.FALSE, stride, offset];
            this._attributes[name] = [vbo._handle, handle, funcname, args];
        }
    };

    Program.prototype._pre_draw = function () {
        var args, attr_handle, dummy29_, dummy30_sequence, dummy31_, dummy32_sequence, funcname, tex_handle, tex_target, unit, vbo_handle, x;
        this.activate();
        dummy30_sequence = this._samplers;
        for (x in dummy30_sequence) {
            if (!dummy30_sequence.hasOwnProperty(x)){ continue; }
            x = dummy30_sequence[x];
            dummy29_ = x;
            tex_target = dummy29_[0];tex_handle = dummy29_[1];unit = dummy29_[2];
            this._gl.activeTexture(this._gl.TEXTURE0 + unit);
            this._gl.bindTexture(tex_target, tex_handle);
        }
        dummy32_sequence = this._attributes;
        for (x in dummy32_sequence) {
            if (!dummy32_sequence.hasOwnProperty(x)){ continue; }
            x = dummy32_sequence[x];
            dummy31_ = x;
            vbo_handle = dummy31_[0];attr_handle = dummy31_[1];funcname = dummy31_[2];args = dummy31_[3];
            if (vbo_handle) {
                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, vbo_handle);
                this._gl.enableVertexAttribArray(attr_handle);
                (this._gl[funcname]).apply(this._gl, [attr_handle].concat(args));
            } else {
                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, null);
                this._gl.disableVertexAttribArray(attr_handle);
                (this._gl[funcname]).apply(this._gl, [attr_handle].concat(args));
            }
        }
        if (!this._validated) {
            this._validated = true;
            this._validate();
        }
    };

    Program.prototype._validate = function () {
        var err_3;
        if (this._unset_variables.length) {
            console.log(('Program has unset variables: ' + this._unset_variables + ''));
        }
        this._gl.validateProgram(this._handle);
        if (!(this._gl.getProgramParameter(this._handle, this._gl.VALIDATE_STATUS))) {
            console.log((this._gl.getProgramInfoLog(this._handle)));
            err_3 = new Error('RuntimeError:' + 'Program validation error'); err_3.name = "RuntimeError"; throw err_3;
        }
    };

    Program.prototype.draw = function (mode, selection) {
        var count, dummy33_, e, err_3, first, gtype;
        // Draw program in given mode, with given selection (IndexBuffer or
        // first, count).
        if (!this._linked) {
            err_3 = new Error('RuntimeError:' + 'Cannot draw program if code has not been set'); err_3.name = "RuntimeError"; throw err_3;
        }
        check_error(this._gl, 'before draw');
        if (selection instanceof IndexBuffer) {
            this._pre_draw();
            selection.activate();
            count = selection._buffer_size / 2;
            gtype = this._gl.UNSIGNED_SHORT;
            this._gl.drawElements(mode, count, gtype, 0);
            selection.deactivate();
        } else {
            dummy33_ = selection;
            first = dummy33_[0];count = dummy33_[1];
            if (count) {
                this._pre_draw();
                this._gl.drawArrays(mode, first, count);
            }
        }
        e = this._gl.getError();
        check_error(this._gl, 'after draw');
    };


    Buffer = function () {
        if (this.__init__) {
           this.__init__.apply(this, arguments);
        }
    };
    Buffer.prototype = Object.create(GlooObject.prototype);
    Buffer.prototype._base_class = GlooObject.prototype;
    

    Buffer.prototype._target = null;
    Buffer.prototype._usage = 35048;
    Buffer.prototype._create = function () {
        this._handle = this._gl.createBuffer();
        this._buffer_size = 0;
    };

    Buffer.prototype.delete = function () {
        this._gl.deleteBuffer(this._handle);
    };

    Buffer.prototype.activate = function () {
        this._gl.bindBuffer(this._target, this._handle);
    };

    Buffer.prototype.deactivate = function () {
        this._gl.bindBuffer(this._target, null);
    };

    Buffer.prototype.set_size = function (nbytes) {
        if (nbytes != this._buffer_size) {
            this.activate();
            this._gl.bufferData(this._target, nbytes, this._usage);
            this._buffer_size = nbytes;
        }
    };

    Buffer.prototype.set_data = function (offset, data) {
        var nbytes;
        this.activate();
        nbytes = data.length * data.BYTES_PER_ELEMENT;
        this._gl.bufferSubData(this._target, offset, data);
    };


    VertexBuffer = function () {
        if (this.__init__) {
           this.__init__.apply(this, arguments);
        }
    };
    VertexBuffer.prototype = Object.create(Buffer.prototype);
    VertexBuffer.prototype._base_class = Buffer.prototype;
    

    VertexBuffer.prototype._target = 34962;

    IndexBuffer = function () {
        if (this.__init__) {
           this.__init__.apply(this, arguments);
        }
    };
    IndexBuffer.prototype = Object.create(Buffer.prototype);
    IndexBuffer.prototype._base_class = Buffer.prototype;
    

    IndexBuffer.prototype._target = 34963;

    Texture2D = function () {
        if (this.__init__) {
           this.__init__.apply(this, arguments);
        }
    };
    Texture2D.prototype = Object.create(GlooObject.prototype);
    Texture2D.prototype._base_class = GlooObject.prototype;
    

    Texture2D.prototype._target = 3553;
    Texture2D.prototype._types = {'Int8Array': 5120, 'Uint8Array': 5121, 'Int16Array': 5122, 'Uint16Array': 5123, 'Int32Array': 5124, 'Int32Array': 5125, 'Float32Array': 5126};
    Texture2D.prototype._create = function () {
        this._handle = this._gl.createTexture();
        this._shape_format = null;
    };

    Texture2D.prototype.delete = function () {
        this._gl.deleteTexture(this._handle);
    };

    Texture2D.prototype.activate = function () {
        this._gl.bindTexture(this._target, this._handle);
    };

    Texture2D.prototype.deactivate = function () {
        this._gl.bindTexture(this._target, 0);
    };

    Texture2D.prototype._get_alignment = function (width) {
        var alignment, alignments, dummy34_sequence, dummy35_iter, dummy36_length;
        // Determines a textures byte alignment.
        // 
        //         If the width isn't a power of 2
        //         we need to adjust the byte alignment of the image.
        //         The image height is unimportant
        // 
        //         www.opengl.org/wiki/Common_Mistakes#Texture_upload_and_pixel_reads
        alignments = [4, 8, 2, 1];
        dummy34_sequence = alignments;
        if ((typeof dummy34_sequence === "object") && (!Array.isArray(dummy34_sequence))) {
            dummy34_sequence = Object.keys(dummy34_sequence);
        }
        dummy36_length = dummy34_sequence.length;
        for (dummy35_iter = 0; dummy35_iter < dummy36_length; dummy35_iter += 1) {
            alignment = dummy34_sequence[dummy35_iter];
            if ((width % alignment) == 0) {
                return alignment;
            }
        }
    };

    Texture2D.prototype.set_wrapping = function (wrap_s, wrap_t) {
        this.activate();
        this._gl.texParameterf(this._target, this._gl.TEXTURE_WRAP_S, wrap_s);
        this._gl.texParameterf(this._target, this._gl.TEXTURE_WRAP_T, wrap_t);
    };

    Texture2D.prototype.set_interpolation = function (min, mag) {
        this.activate();
        this._gl.texParameterf(this._target, this._gl.TEXTURE_MIN_FILTER, min);
        this._gl.texParameterf(this._target, this._gl.TEXTURE_MAG_FILTER, mag);
    };

    Texture2D.prototype.set_size = function (shape, format) {
        var dummy37_, height, width;
        dummy37_ = shape;
        height = dummy37_[0];width = dummy37_[1];
        if (([height, width, format]) != this._shape_format) {
            this._shape_format = [height, width, format];
            this.activate();
            this._gl.texImage2D(this._target, 0, format, width, height, 0, format, this._gl.UNSIGNED_BYTE, null);
        }
    };

    Texture2D.prototype.set_data = function (offset, shape, data) {
        var alignment, dummy38_, dummy39_, dummy40_, err_3, format, gtype, height, width, x, y;
        this.activate();
        format = this._shape_format[2];
        dummy38_ = shape;
        height = dummy38_[0];width = dummy38_[1];
        dummy39_ = offset;
        y = dummy39_[0];x = dummy39_[1];
        gtype = (/*py-dict.get*/typeof (dummy40_=this._types).get==="function" ? dummy40_.get(data.constructor.name, null) : (dummy40_[data.constructor.name] || null));
        if (gtype === null) {
            err_3 = new Error('ValueError:' + ('Type ' + data.constructor.name + ' not allowed for texture')); err_3.name = "ValueError"; throw err_3;
        }
        alignment = this._get_alignment((shape[shape.length -2]) * (shape[shape.length -1]));
        if (alignment != 4) {
            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, alignment);
        }
        this._gl.texSubImage2D(this._target, 0, x, y, width, height, format, gtype, data);
        if (alignment != 4) {
            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 4);
        }
    };


    return {'Buffer': Buffer, 'GlooObject': GlooObject, 'IndexBuffer': IndexBuffer, 'Program': Program, 'Texture2D': Texture2D, 'VertexBuffer': VertexBuffer, 'check_error': check_error};
}));
