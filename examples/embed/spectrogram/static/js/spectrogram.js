// Generated by CoffeeScript 1.9.2
(function() {
  var RadialHistogramPlot, SimpleXYPlot, SpectrogramApp, SpectrogramPlot, _, find_glyph_renderer, get_plot_id, setup, timer,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = Bokeh._;

  find_glyph_renderer = function(index_item) {
    var data_source, key, r, ref;
    ref = index_item.renderers;
    for (key in ref) {
      r = ref[key];
      data_source = r.model.get('data_source');
      if (data_source != null) {
        return r.model;
      }
    }
    return null;
  };

  get_plot_id = function(id) {
    var item;
    item = Bokeh.$('#' + id + ' > .plotdiv');
    if (item.length === 1) {
      return item[0].id;
    }
    return null;
  };

  SpectrogramApp = (function() {
    function SpectrogramApp(keys1) {
      var config, item, item_id, k, key, len, ref;
      this.keys = keys1;
      this.request_data = bind(this.request_data, this);
      this.update_gain = bind(this.update_gain, this);
      this.update_freq = bind(this.update_freq, this);
      this.paused = false;
      this.gain = 1;
      ref = this.keys;
      for (k = 0, len = ref.length; k < len; k++) {
        key = ref[k];
        item = Bokeh.index[key];
        item_id = item.el.id;
        if (item_id === get_plot_id('freq-slider')) {
          this.freq_slider = item;
        }
        if (item_id === get_plot_id('gain-slider')) {
          this.gain_slider = item;
        }
        if (item_id === get_plot_id('spectrogram')) {
          this.spectrogram = item;
        }
        if (item_id === get_plot_id('signal')) {
          this.signal = item;
        }
        if (item_id === get_plot_id('spectrum')) {
          this.spectrum = item;
        }
        if (item_id === get_plot_id('equalizer')) {
          this.equalizer = item;
        }
      }
      this.freq_slider.on("change:value", this.update_freq);
      this.gain_slider.on("change:value", this.update_gain);
      config = Bokeh.$.ajax('http://localhost:5000/params', {
        type: 'GET',
        dataType: 'json',
        cache: false
      }).done((function(_this) {
        return function(data, textStatus, jqXHR) {
          return _this._config(data);
        };
      })(this)).then(this.request_data);
    }

    SpectrogramApp.prototype.update_freq = function() {
      var freq;
      freq = this.freq_slider.get('value');
      this.spectrogram_plot.set_yrange(0, freq);
      return this.power_plot.set_xrange(0, freq);
    };

    SpectrogramApp.prototype.update_gain = function() {
      return this.gain = this.gain_slider.get('value');
    };

    SpectrogramApp.prototype._config = function(data) {
      this.config = data;
      console.log("Got config:", this.config);
      this.spectrogram_plot = new SpectrogramPlot(find_glyph_renderer(this.spectrogram), this.config);
      this.signal_plot = new SimpleXYPlot(find_glyph_renderer(this.signal), this.config);
      this.power_plot = new SimpleXYPlot(find_glyph_renderer(this.spectrum), this.config);
      return this.eq_plot = new RadialHistogramPlot(find_glyph_renderer(this.equalizer), this.config);
    };

    SpectrogramApp.prototype.request_data = function() {
      var helper, in_flight, looper;
      in_flight = false;
      helper = (function(_this) {
        return function() {
          if (in_flight) {
            return;
          }
          in_flight = true;
          return Bokeh.$.ajax('/data', {
            type: 'GET',
            dataType: 'json',
            cache: false
          }).fail(in_flight = false).then(function(data) {
            in_flight = false;
            return _this.on_data(data);
          });
        };
      })(this);
      this.interval = Math.floor(1000.0 / this.config.FRAMES_PER_SECOND);
      this.thisTime = Date.now();
      this.lastTime = Date.now();
      looper = (function(_this) {
        return function() {
          var delay, timeout;
          _this.thisTime = Date.now();
          _this.deltaTime = _this.thisTime - _this.lastTime;
          delay = Math.max(_this.interval - _this.deltaTime, 0);
          timeout = setTimeout(looper, delay);
          _this.lastTime = _this.thisTime + delay;
          return helper();
        };
      })(this);
      return setTimeout(looper, 0);
    };

    SpectrogramApp.prototype.on_data = function(data) {
      var f, i, power, signal, spectrum, t, x;
      if (_.keys(data).length === 0) {
        return;
      }
      signal = (function() {
        var k, len, ref, results;
        ref = data.signal;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          x = ref[k];
          results.push(x * this.gain);
        }
        return results;
      }).call(this);
      spectrum = (function() {
        var k, len, ref, results;
        ref = data.spectrum;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          x = ref[k];
          results.push(x * this.gain);
        }
        return results;
      }).call(this);
      power = (function() {
        var k, len, ref, results;
        ref = data.spectrum;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          x = ref[k];
          results.push(x * x);
        }
        return results;
      })();
      this.spectrogram_plot.update(spectrum);
      t = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = signal.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
          results.push(i / signal.length * this.config.TIMESLICE);
        }
        return results;
      }).call(this);
      this.signal_plot.update(t, signal);
      f = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = spectrum.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
          results.push(i / spectrum.length * this.config.MAX_FREQ);
        }
        return results;
      }).call(this);
      this.power_plot.update(f, spectrum);
      return this.eq_plot.update(data.bins);
    };

    return SpectrogramApp;

  })();

  SpectrogramPlot = (function() {
    function SpectrogramPlot(model, config1) {
      var i, k, plot, ref;
      this.model = model;
      this.config = config1;
      this.source = this.model.get('data_source');
      this.cmap = new Bokeh.LinearColorMapper.Model({
        palette: Bokeh.Palettes.YlGnBu9,
        low: 0,
        high: 5
      });
      plot = this.model.attributes.parent;
      this.y_range = plot.get('frame').get('y_ranges')[this.model.get('y_range_name')];
      this.num_images = Math.ceil(this.config.NGRAMS / this.config.TILE_WIDTH) + 1;
      this.image_width = this.config.TILE_WIDTH;
      this.images = new Array(this.num_images);
      for (i = k = 0, ref = this.num_images - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        this.images[i] = new ArrayBuffer(this.config.SPECTROGRAM_LENGTH * this.image_width * 4);
      }
      this.xs = new Array(this.num_images);
      this.col = 0;
    }

    SpectrogramPlot.prototype.update = function(spectrum) {
      var buf, buf32, i, image32, img, k, l, ref, ref1;
      buf = this.cmap.v_map_screen(spectrum);
      for (i = k = 0, ref = this.xs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        this.xs[i] += 1;
      }
      this.col -= 1;
      if (this.col === -1) {
        this.col = this.image_width - 1;
        img = this.images.pop();
        this.images = [img].concat(this.images.slice(0));
        this.xs.pop();
        this.xs = [1 - this.image_width].concat(this.xs.slice(0));
        this.source.set('data', {
          image: this.images,
          x: this.xs
        });
      }
      image32 = new Uint32Array(this.images[0]);
      buf32 = new Uint32Array(buf);
      for (i = l = 0, ref1 = this.config.SPECTROGRAM_LENGTH; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
        image32[i * this.image_width + this.col] = buf32[i];
      }
      this.source.get('data')['x'] = this.xs;
      return this.source.trigger('change', true, 0);
    };

    SpectrogramPlot.prototype.set_yrange = function(y0, y1) {
      return this.y_range.set({
        'start': y0,
        'end': y1
      });
    };

    return SpectrogramPlot;

  })();

  RadialHistogramPlot = (function() {
    function RadialHistogramPlot(model, config1) {
      this.model = model;
      this.config = config1;
      this.source = this.model.get('data_source');
    }

    RadialHistogramPlot.prototype.update = function(bins) {
      var alpha, angle, end, i, inner, j, k, l, outer, range, ref, ref1, ref2, results, start;
      angle = 2 * Math.PI / bins.length;
      ref = [[], [], [], [], []], inner = ref[0], outer = ref[1], start = ref[2], end = ref[3], alpha = ref[4];
      for (i = k = 0, ref1 = bins.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
        range = (function() {
          results = [];
          for (var l = 0, ref2 = Math.min(Math.ceil(bins[i]), this.config.EQ_CLAMP); 0 <= ref2 ? l < ref2 : l > ref2; 0 <= ref2 ? l++ : l--){ results.push(l); }
          return results;
        }).apply(this);
        inner = inner.concat((function() {
          var len, m, results1;
          results1 = [];
          for (m = 0, len = range.length; m < len; m++) {
            j = range[m];
            results1.push(j + 2);
          }
          return results1;
        })());
        outer = outer.concat((function() {
          var len, m, results1;
          results1 = [];
          for (m = 0, len = range.length; m < len; m++) {
            j = range[m];
            results1.push(j + 2.95);
          }
          return results1;
        })());
        start = start.concat((function() {
          var len, m, results1;
          results1 = [];
          for (m = 0, len = range.length; m < len; m++) {
            j = range[m];
            results1.push((i + 0.05) * angle);
          }
          return results1;
        })());
        end = end.concat((function() {
          var len, m, results1;
          results1 = [];
          for (m = 0, len = range.length; m < len; m++) {
            j = range[m];
            results1.push((i + 0.95) * angle);
          }
          return results1;
        })());
        alpha = alpha.concat((function() {
          var len, m, results1;
          results1 = [];
          for (m = 0, len = range.length; m < len; m++) {
            j = range[m];
            results1.push(1 - 0.08 * j);
          }
          return results1;
        })());
      }
      this.source.set('data', {
        inner_radius: inner,
        outer_radius: outer,
        start_angle: start,
        end_angle: end,
        fill_alpha: alpha
      });
      return this.source.trigger('change', this.source);
    };

    return RadialHistogramPlot;

  })();

  SimpleXYPlot = (function() {
    function SimpleXYPlot(model, config1) {
      var plot;
      this.model = model;
      this.config = config1;
      this.source = this.model.get('data_source');
      plot = this.model.attributes.parent;
      this.x_range = plot.get('frame').get('x_ranges')[this.model.get('x_range_name')];
    }

    SimpleXYPlot.prototype.update = function(x, y) {
      this.source.set('data', {
        x: x,
        y: y
      });
      return this.source.trigger('change', this.source);
    };

    SimpleXYPlot.prototype.set_xrange = function(x0, x1) {
      return this.x_range.set({
        'start': x0,
        'end': x1
      });
    };

    return SimpleXYPlot;

  })();

  setup = function() {
    var app, index, keys;
    index = window.Bokeh.index;
    keys = _.keys(index);
    if (keys.length === 0) {
      console.log("Bokeh not loaded yet, waiting to set up SpectrogramApp...");
      return;
    }
    clearInterval(timer);
    console.log("Bokeh loaded, starting SpectrogramApp");
    return app = new SpectrogramApp(keys);
  };

  timer = setInterval(setup, 100);

}).call(this);
